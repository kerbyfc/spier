// Generated by CoffeeScript 1.4.0
(function() {
  var Comparator, Dir, File, Spier, fs, mm,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  mm = require('minimatch');

  Array.prototype.diff = function(arr) {
    return this.filter(function(i) {
      return !(arr.indexOf(i) > -1);
    });
  };

  File = (function() {

    File.prototype.stat = function() {
      var parts, _ref;
      parts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return fs.statSync((_ref = File.prototype).path.apply(_ref, parts));
    };

    File.prototype.path = function() {
      var parts;
      parts = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return parts.join(Dir.prototype.separator);
    };

    File.prototype["new"] = function(path, stat) {
      if (stat == null) {
        stat = File.prototype.stat(path);
      }
      if (stat.isDirectory()) {
        return new Dir(path, stat);
      } else {
        return new File(path, stat);
      }
    };

    function File(path, stat) {
      this.path = path;
      this.name = this.path.split(Dir.prototype.separator).slice(-1)[0];
      this.stat = stat;
    }

    return File;

  })();

  Dir = (function() {

    Dir.prototype.separator = process.platform.match(/^win/) != null ? '\\' : '/';

    function Dir(path, stat) {
      this.read = __bind(this.read, this);
      this.path = path;
      this.files = {};
      this.ignore = [];
      this.step = 0;
      this.options = {};
      this.name = this.path.split(Dir.prototype.separator).slice(-1)[0];
      this.stat = stat;
      this.existed = [];
      this.cache = {};
      this.empty = [];
    }

    Dir.prototype.__ignore = function(path) {
      return !((this.options.ignore != null) && !!this.options.ignore.test(path));
    };

    Dir.prototype.__filter = function(path) {
      return (this.options.filter != null) && !!this.options.filter.test(path);
    };

    Dir.prototype.__pattern = function(path) {
      return (this.options.pattern != null) && !!mm(path, this.options.pattern, {
        matchBase: true
      });
    };

    Dir.prototype.suitable = function(filename) {
      var path, stat;
      path = File.prototype.path(this.path, filename);
      stat = File.prototype.stat(path);
      if (stat.isDirectory() || Spier.comparator.compare(path)) {
        this.cache[filename] = File.prototype["new"](path, stat);
        if (this.options.skip_empty !== void 0 && this.cache[filename].stat.isDirectory() && this.cache[filename].read(this.options).current.length === 0) {
          this.empty.push(filename);
          return false;
        }
        return true;
      } else {
        if (!stat.isDirectory()) {
          this.ignore.push(filename);
        }
        return false;
      }
    };

    Dir.prototype.read = function() {
      var filename, _i, _len, _ref;
      if (this.step !== options.step) {
        this.current = [];
        this.empty = [];
        _ref = fs.readdirSync(this.path);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          filename = _ref[_i];
          if (__indexOf.call(this.ignore, filename) < 0 && this.suitable(filename)) {
            this.current.push(filename);
          }
        }
        this.step = options.step;
      }
      return this;
    };

    Dir.prototype.invoke = function() {
      var data, event, tmp, _ref;
      event = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if ((tmp = this[event].apply(this, data))) {
        return (_ref = Spier.prototype)[event].apply(_ref, tmp);
      }
    };

    Dir.prototype.create = function(filename) {
      if (__indexOf.call(this.empty, filename) < 0) {
        this.files[filename] = this.cache[filename] != null ? (function(d) {
          return d;
        })(this.cache[filename]) : File.prototype["new"](File.prototype.path(this.path, filename));
        return [this.files[filename]];
      }
      return false;
    };

    Dir.prototype.remove = function(filename) {
      var tmp,
        _this = this;
      tmp = (function() {
        return _this.files[filename];
      })();
      delete this.files[filename];
      return [tmp];
    };

    Dir.prototype.rename = function(oldname, newname) {
      this.files[newname] = this.files[oldname];
      this.files[newname].path = File.prototype.path(this.path, newname);
      this.files[newname].name = newname;
      delete this.files[oldname];
      return [File.prototype.path(this.path, oldname), this.files[newname].path, this.files[newname]];
    };

    Dir.prototype.change = function(filename) {
      var tmp;
      if (!this.files[filename].stat.isDirectory() && (tmp = File.prototype["new"](File.prototype.path(this.path, filename))) && this.files[filename].stat.ctime.getTime() !== tmp.stat.ctime.getTime()) {
        this.files[filename].stat = tmp.stat;
        return [this.files[filename]];
      }
      return false;
    };

    Dir.prototype.filenames = function() {
      var file, name, _ref, _results;
      _ref = this.files;
      _results = [];
      for (name in _ref) {
        file = _ref[name];
        _results.push(name);
      }
      return _results;
    };

    Dir.prototype.filepaths = function(filenames) {
      var filename, _i, _len, _results;
      if (filenames == null) {
        filenames = this.filenames();
      }
      _results = [];
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        filename = filenames[_i];
        _results.push(File.prototype.path(this.path, filename));
      }
      return _results;
    };

    Dir.prototype.directories = function() {
      var file, name, _ref, _results;
      _ref = this.files;
      _results = [];
      for (name in _ref) {
        file = _ref[name];
        if (file.stat.isDirectory()) {
          _results.push(file);
        }
      }
      return _results;
    };

    Dir.prototype.compare = function() {
      var created, current, existed, file, removed, subdir, subdirs, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _results;
      existed = this.existed;
      current = this.current;
      created = current.diff(existed);
      removed = existed.diff(current);
      if (removed.length === created.length && created.length === 1) {
        this.invoke('rename', removed[0], created[0]);
      } else {
        for (_i = 0, _len = created.length; _i < _len; _i++) {
          file = created[_i];
          this.invoke('create', file);
        }
        for (_j = 0, _len1 = removed.length; _j < _len1; _j++) {
          file = removed[_j];
          this.invoke('remove', file);
        }
        _ref = existed.diff(removed);
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          file = _ref[_k];
          this.invoke('change', file);
        }
      }
      subdirs = this.directories();
      this.existed = (function(c) {
        return c;
      })(current);
      if (subdirs.length > 0) {
        _results = [];
        for (_l = 0, _len3 = subdirs.length; _l < _len3; _l++) {
          subdir = subdirs[_l];
          _results.push(subdir.read(this.options).compare());
        }
        return _results;
      }
    };

    return Dir;

  })();

  Comparator = (function() {

    Comparator.prototype.comparisions = [];

    Comparator.prototype.map = {
      i: 'ignore',
      f: 'filter',
      p: 'pattern'
    };

    Comparator.prototype.combos = {
      '*': function(a, b) {
        return a && b;
      },
      '+': function(a, b) {
        return a || b;
      }
    };

    function Comparator(rules, data) {
      var char, combo, _i, _len, _ref;
      if (rules == null) {
        rules = 'p+i*f';
      }
      if (data == null) {
        data = {};
      }
      this._pattern = __bind(this._pattern, this);

      this._filter = __bind(this._filter, this);

      this._ignore = __bind(this._ignore, this);

      this.rules = rules.toLowerCase();
      this.data = data;
      combo = this.combos['*'];
      _ref = this.rules.split('');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        char = _ref[_i];
        if (char.match(/\w/) != null) {
          if (this.data[this.map[char]] !== void 0) {
            this.comparisions.push({
              combo: combo,
              fn: this['_' + this.map[char]],
              type: this.map[char]
            });
          }
        } else {
          combo = this.combos[char];
        }
      }
      console.log(this.comparisions);
    }

    Comparator.prototype.compare = function(path, result) {
      var comparision, _i, _len, _ref;
      if (result == null) {
        result = true;
      }
      _ref = this.comparisions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        comparision = _ref[_i];
        result = comparision.combo(result, comparision.fn(path));
        console.log(comparision.type.toUpperCase(), this.data[comparision.type], 'in', path, comparision.fn(path));
      }
      return console.log("> include", path, result);
    };

    Comparator.prototype._ignore = function(str) {
      return !((this.data.ignore != null) && !this.data.ignore.test(str));
    };

    Comparator.prototype._filter = function(str) {
      return (this.data.filter != null) && !!this.data.filter.test(str);
    };

    Comparator.prototype._pattern = function(str) {
      return (this.data.pattern != null) && !!mm(str, this.data.pattern, {
        matchBase: true
      });
    };

    return Comparator;

  })();

  Spier = (function() {

    Spier.prototype.handlers = {
      create: function() {},
      remove: function() {},
      change: function() {},
      rename: function() {}
    };

    Spier.prototype.delay = 50;

    Spier.prototype.pause = false;

    Spier.prototype.options = {
      step: 1,
      ignore_flags: '',
      filter_flags: ''
    };

    Spier.prototype.shutdown = function(msg) {
      console.log(msg);
      return process.exit(0);
    };

    Spier.prototype.isRegExp = function(rg) {
      if (typeof rg === 'object') {
        rg = rg.toString();
      }
      if (!(rg.slice(0, 1)[0] === '/' && rg.slice(-1)[0] === '/')) {
        rg = "/" + rg + "/";
      }
      return rg.match(/\/.*\/(.?)$/) != null;
    };

    function Spier(root, options) {
      var stat;
      if (root == null) {
        root = null;
      }
      if (options == null) {
        options = {};
      }
      if (root == null) {
        this.shutdown('Specify directory path for spying. Use spy --help');
      }
      try {
        stat = File.prototype.stat(root);
      } catch (e) {
        this.shutdown(root + ' doesn`t exists');
      }
      if (!stat.isDirectory()) {
        this.shutdown(root + ' is not a directory');
      }
      this.setup(options);
      this.scope = File.prototype["new"](root, stat);
    }

    Spier.prototype.setup = function(options) {
      var compares, excerpt, k, v, _i, _len, _ref, _ref1;
      compares = {};
      _ref = ['ignore', 'filter'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        excerpt = _ref[_i];
        if (options[excerpt] && (options[excerpt] != null)) {
          if (this.isRegExp(options[excerpt])) {
            compares[excerpt] = typeof options[excerpt] === 'string' ? new RegExp(options[excerpt], this.options[excerpt + '_flags']) : options[excerpt];
          } else {
            this.shutdown(excerpt + ' is not a valid regexp');
          }
          delete options[excerpt];
        }
      }
      if (options.pattern && (options.pattern != null)) {
        compares.pattern = options.pattern;
        delete options.pattern;
      }
      Spier.comparator = new Comparator((_ref1 = options.rules) != null ? _ref1 : options.rules = null, compares);
      for (k in options) {
        v = options[k];
        this.options[k] = v;
      }
      return this;
    };

    Spier.prototype.lookout = function() {
      var _this = this;
      this.scope.read().compare();
      if (!this.pause) {
        return setTimeout(function() {
          _this.lookout();
          return _this.options.step++;
        }, this.delay);
      }
    };

    Spier.prototype.pause = function() {
      return this.pause = true;
    };

    Spier.prototype.spy = function() {
      this.step = 0;
      this.pause = false;
      return this.lookout();
    };

    Spier.prototype.on = function(event, handler) {
      var _this = this;
      Spier.prototype[event] = function() {
        if (!(_this.options.step === 1 && _this.options.existing === void 0)) {
          return handler.apply(null, arguments);
        }
      };
      return this;
    };

    return Spier;

  })();

  module.exports = Spier;

}).call(this);
