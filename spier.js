// Generated by CoffeeScript 1.4.0
(function() {
  var Spier, fs, path, rexp, sDir, sFile, sNoop, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  rexp = require('rexp');

  path = require('path');

  _ = require('underscore');

  sFile = (function() {

    sFile["new"] = function(_path, opts) {
      var stat;
      if (opts == null) {
        opts = {};
      }
      if ((stat = Spier.stat(_path)) && (opts = _.extend({}, opts, {
        stat: stat,
        path: _path,
        name: path.basename(_path)
      })) && stat.isDirectory()) {
        return new sDir(opts);
      } else {
        return new sFile(opts);
      }
    };

    function sFile(opts) {
      if (opts == null) {
        opts = {};
      }
      _.extend(this, opts);
    }

    return sFile;

  })();

  global.sFile = sFile;

  sDir = (function() {

    sDir.prototype.defaults = {
      files: {},
      cache: {},
      step: {}
    };

    function sDir(opts) {
      if (opts == null) {
        opts = {};
      }
      this.setup(opts);
    }

    sDir.prototype.setup = function(opts) {
      return _.extend(this, this.defaults, opts);
    };

    sDir.prototype.reindex = function() {
      this.index.existed = _.clone(this.index.current);
      return this.index.current = [];
    };

    sDir.prototype.clearCache = function(stat) {
      var _ref;
      return _ref = [{}, stat], this.cache = _ref[0], this.stat = _ref[1], _ref;
    };

    sDir.prototype.cleanup = function(stat) {
      if (stat == null) {
        stat = this.stat;
      }
      return this.reindex(this.clearCache(stat));
    };

    sDir.prototype.get = function(filename) {
      return this.cache[filename] || sFile["new"](path.join(this.path, filename), this);
    };

    sDir.prototype.isChanged = function() {
      var stat;
      if (this.lazy && (stat = Spier.stat(this.path)) && stat.atime.getTime() !== this.stat.atime.getTime()) {
        return this.cleanup(stat);
      } else {
        return false;
      }
    };

    sDir.prototype.goDown = function() {
      var file, _i, _len, _ref, _results;
      _ref = this.index.files;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        if (file.stat.isDirectory()) {
          _results.push(this.files[file].compare());
        }
      }
      return _results;
    };

    sDir.prototype.filenames = function() {
      var file, name, _ref, _results;
      _ref = this.files;
      _results = [];
      for (name in _ref) {
        file = _ref[name];
        _results.push(name);
      }
      return _results;
    };

    sDir.prototype.paths = function(filenames) {
      var filename, _i, _len, _results;
      if (filenames == null) {
        filenames = this.filenames();
      }
      _results = [];
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        filename = filenames[_i];
        _results.push(path.join(this.path, filename));
      }
      return _results;
    };

    sDir.prototype.directories = function() {
      var file, name, _ref, _results;
      _ref = this.files;
      _results = [];
      for (name in _ref) {
        file = _ref[name];
        if (file.stat.isDirectory()) {
          _results.push(file);
        }
      }
      return _results;
    };

    sDir.prototype.read = function() {
      var filename, _i, _len, _ref;
      _ref = fs.readdirSync(this.path);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filename = _ref[_i];
        if (__indexOf.call(this.index.ignored, filename) < 0) {
          this.add(filename);
        }
      }
      return this;
    };

    sDir.prototype.add = function(filename) {
      if (__indexOf.call(this.index.existed, filename) >= 0 || this.check(filename)) {
        return this.index.current.push(filename);
      }
    };

    sDir.prototype.check = function() {
      if (this.isChanged() || !_.size(this.files)) {
        return this.compare();
      } else {
        return this.goDown();
      }
    };

    sDir.prototype.compare = function() {
      if (this.involveRename()) {
        return this.invoke('rename', this.step.rename[0], this.step.create[0]);
      } else {
        return this.handle(this.step.change = _.difference(this.index.existed, this.step.remove));
      }
    };

    sDir.prototype.handle = function() {
      var event, file, files, _i, _len, _ref;
      _ref = this.step;
      for (event in _ref) {
        files = _ref[event];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          this.invoke(event, file);
        }
      }
      return this.goDown();
    };

    sDir.prototype.involveRename = function() {
      return this.difference().remove.length === this.step.created.length && this.step.created.length === 1;
    };

    sDir.prototype.difference = function() {
      return this.read().step = {
        create: _.difference(this.index.current, this.index.existed),
        remove: _.difference(this.index.existed, this.index.current)
      };
    };

    sDir.prototype.isInIgnore = function(_path) {
      return (this.options.ignore != null) && this.options.ignore.test(_path);
    };

    sDir.prototype.matchPattern = function(_path) {
      return !(this.options.target != null) || this.options.target.test(_path);
    };

    sDir.prototype.ignore = function(filename) {
      this.index.ignored.push(filename);
      return false;
    };

    sDir.prototype.check = function(filename) {
      var stat, _path;
      _path = path.join(this.path, filename);
      if (this.isInIgnore(_path)) {
        return this.ignore(filename);
      }
      stat = Spier.stat(_path);
      if (!this.matchPattern(_path) && !stat.isDirectory()) {
        return this.ignore(filename);
      } else {
        return this.cache[filename] = stat.isDirectory() ? new sDir(_path, stat, this.options, this) : new File(_path, stat);
      }
    };

    sDir.prototype.archive = function(filename, event, file) {
      var _base, _ref;
      if ((_ref = (_base = this.history)[filename]) == null) {
        _base[filename] = [];
      }
      this.history[filename].push([event, file]);
      if (this.history[filename].length > 20) {
        return this.history[filename].shift();
      }
    };

    sDir.prototype.trigger = function(event, file) {
      if (this.step) {
        Spier.instances[this.options.id].handlers[event](file);
      }
      return this.archive(file.name, event, file);
    };

    sDir.prototype.invoke = function() {
      var data, event, file;
      event = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if ((file = this["_" + event].apply(this, data))) {
        return this.trigger(event, file);
      }
    };

    sDir.prototype._create = function(filename, file) {
      if (file == null) {
        file = false;
      }
      this.files[filename] = file || this.cached(filename);
      if (this.files[filename].stat.isDirectory()) {
        this.index.subdirs.push(filename);
        this.subdirs = true;
      }
      if (this.files[filename].stat.isDirectory() && (!this.options.folders || this.options.skipEmpty)) {
        return false;
      } else {
        if (this.options.skipEmpty && (this.parent != null) && !this.parent.history[this.name]) {
          this.parent.trigger('create', this);
          if (!this.files[filename].stat.isDirectory()) {
            return this.files[filename];
          } else {
            return false;
          }
        } else {
          return this.files[filename];
        }
      }
    };

    sDir.prototype._remove = function(filename) {
      var tmp,
        _this = this;
      tmp = (function() {
        return _this.files[filename];
      })();
      delete this.files[filename];
      return tmp;
    };

    sDir.prototype._rename = function(oldname, newname) {
      this.files[newname] = this.files[oldname];
      this.files[newname].path = path.join(this.path, newname);
      this.files[newname].name = newname;
      this.files[newname].lastname = oldname;
      delete this.files[oldname];
      return this.files[newname];
    };

    sDir.prototype._change = function(filename) {
      var curr;
      curr = Spier.stat(this.path, filename);
      if (curr.isDirectory() && (this.files[filename].stat.atime.getTime() !== curr.atime.getTime() || this.files[filename].subdirs)) {
        this.files[filename].stat = curr;
        this.index.subdirs.push(filename);
        return false;
      } else if (!curr.isDirectory() && this.files[filename].stat.ctime.getTime() !== curr.ctime.getTime()) {
        this.files[filename].stat = curr;
        return this.files[filename];
      } else {
        return false;
      }
    };

    return sDir;

  })();

  global.sDir = sDir;

  sNoop = (function() {

    function sNoop(e) {
      this.fire = __bind(this.fire, this);
      this.e = e;
    }

    sNoop.prototype.fire = function(file) {
      return console.log("" + this.event + " " + file.stat.isDirectory() ? 'directory' : 'file' + " " + file.path);
    };

    return sNoop;

  })();

  Spier = (function() {

    Spier.spy = function(target, options) {
      return new Spier(options).spy(target);
    };

    Spier.stat = function() {
      var slices;
      slices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return fs.statSync(path.join.apply(path, slices));
    };

    Spier.shutdown = function(msg) {
      if (msg == null) {
        msg = 'Unknown error';
      }
      console.error(msg);
      return process.exit(0);
    };

    Spier.prototype.defaults = {
      ignore: null,
      target: null
    };

    Spier.prototype.flags = {
      strict: false,
      primary: false,
      folders: false,
      dotfiles: false,
      noops: false
    };

    Spier.prototype.delay = 50;

    function Spier(opts, options, handlers) {
      var event, _i, _len, _ref;
      if (opts == null) {
        opts = {};
      }
      this.options = options != null ? options : {};
      this.handlers = handlers != null ? handlers : {};
      this.configure(opts);
      if (this.options.noops) {
        _ref = ['create', 'remove', 'rename', 'change'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          event = _ref[_i];
          this.handlers[event] = (new sNoop(event)).fire;
        }
      }
    }

    Spier.prototype.configure = function(opts) {
      var option, value, _ref;
      _ref = _.extend({}, this.flags, this.defaults, opts);
      for (option in _ref) {
        value = _ref[option];
        this.setup(option, value);
      }
      return this;
    };

    Spier.prototype.setup = function(option, value) {
      return this.options[option] = option !== 'ignore' && option !== 'target' ? value : rexp.create(value, {
        dot: this.options.dotfiles
      });
    };

    Spier.prototype.spy = function(target) {
      if (target == null) {
        target = './**/*';
      }
      this.setup('target', target);
      return this.start();
    };

    Spier.prototype.start = function(pause) {
      this.pause = pause != null ? pause : false;
      this.scope = sFile["new"]('.', {
        options: this.options
      });
      return this.lookout();
    };

    Spier.prototype.stop = function(pause) {
      this.pause = pause != null ? pause : true;
      this.timeout = clearTimeout(this.timeout) || null;
      return this;
    };

    Spier.prototype.lookout = function() {
      var _this = this;
      if (!this.pause) {
        this.timeout = setTimeout(function() {
          _this.scope.check();
          return _this.lookout();
        }, this.delay);
      }
      return this;
    };

    Spier.prototype.on = function(event, handler) {
      this.handlers[event] = handler;
      return this;
    };

    Spier.prototype.off = function(event) {
      return delete this.handlers[event];
    };

    return Spier;

  })();

  module.exports = Spier;

}).call(this);
